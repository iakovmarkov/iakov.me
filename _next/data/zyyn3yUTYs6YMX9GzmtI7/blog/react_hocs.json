{"pageProps":{"raw":"---\r\ntitle: Higher-Order Components in React\r\ndate: 2017-10-21\r\ntags:\r\n- Programming\r\n- Functional programming\r\n- React\r\n- Inferno\r\n- JavaScript\r\n---\r\nThis post will talk about a key conecpt in functional programming, and demonstrate it on a more-or-less practical example. \r\n---\r\n\r\n## Intro\r\n\r\nMost React developers are using object-oriented approach to React components. They create classes that tightly couple business logic with JSX code. By using functional components and composition, you can split the code very much like MVC pattern suggests. This will ensure a greater degree of separation of concerns in your code, and will make your components easier to reuse and refactor. Moreover, you can combine multiple higher-order functions into one, reusable function. This is very useful for functionality that you repeat in multiple places, like working with a REST API or validating form input.\r\n\r\nA small, but nevertheless cool thing about separating view code from business logic is that you, as a developer, can replace React with any other similar view library. The practical application of this is very limited, but I'm going to show you how it's done in the very end of this blog post.\r\n\r\nIf you're not familiar with functional programming, I'd recommend taking a look at [Funcitonal Programming in React](/blog/functional-react). \r\n\r\n## Functional composition\r\n\r\nFunctional composition is a way to use simple functions together to get a complex behaviour. Consider this example:\r\n\r\n```javascript\r\nconst getCartTotal = (prices) => {\r\n  const pricesWithTax = prices.map(p => p * 1.22)\r\n  const priceTotal = pricesWithTax.reduce((p, acc) => acc += p, 0)\r\n  const priceTotalRounded = Number(priceTotal.toFixed(2))\r\n\r\n  return priceTotalRounded\r\n}\r\n\r\ngetCartTotal([4, 8, 1]) // 15.86\r\n```\r\n\r\nThis function works well to get total price for every item in cart. But if I need to implement a function that will calculate the cart total without tax, or a price of each item with tax, I'll be tempted to copy-and-paste the code from `getCartTotal` function. \r\n\r\nA better idea is to refactor `getCartTotal` into few functions that adhere to Single Responsibility Principle and use them together. This is how it can look like:\r\n\r\n```javascript\r\nconst map = (fn) => (value) => value.map(fn)\r\nconst addTax = (value) => value * 1.22\r\nconst sum = (values) => values.reduce((acc, value) => acc += value, 0)\r\nconst round = (pos = 2) => (value) => Number(value.toFixed(pos))\r\n\r\nconst getCartTotal = (prices) => round(2)(sum(map(addTax)(prices)))\r\n\r\ngetCartTotal([4, 8, 1]) // 15.86\r\n```\r\n\r\nThe result is the same, and the new `addTax`, `sum` and `round` functions look pretty generic and reusable. The only thing that is objectively bad here is `round(2)(sum(map(addTax)(prices)))`. It's just hard to read.\r\n\r\nWhen JS is executing this line, it runs the innermost function, and passes it's return value to another function. We can write a function that will do exactly this, but with a more readable synthax:\r\n\r\n```jsx\r\nconst compose = (...functors) => \r\n  functors.reduce(\r\n      (s, c) => (...args) => c(s(...args))\r\n  )\r\n\r\nconst getCartTotal = compose(\r\n  round(2),\r\n  sum,\r\n)\r\n\r\nconst getCartTotalWithTax = compose(\r\n  map(addTax),\r\n  sum,\r\n  round(2),\r\n)\r\n\r\ngetCartTotal([4, 8, 1]) // 15.86\r\ngetCartTotalWithTax([4, 8, 1]) // 15.86\r\n```\r\n\r\nSo what have we achieved? We have reduced the amount of code that gets copied around in the project. If I need to change the tax percent - I can change it in one place, and have the change propagate across my project. It's also very easy to change the amount of decimals when needed, without duplicating the conversion snippet. The new functions are simpler and therefore more testable.\r\n\r\n## Higher-order components in React\r\n\r\nLet's take a dive in functional React now. We will refactor a traditional class into functional component, write a few HOCs and glue them together. In the end, we'll try to replace React with Inferno - just for fun.\r\n\r\n### Class component\r\n\r\nWe have a very basic React component - a shopping list. This shopping list calls an API when itâ€™s mounted, has some basic performance optimization built in, and has a simple render method:\r\n\r\n```jsx\r\nclass ShoppingList extends React.Component {\r\n  state = {\r\n    items: []\r\n  }\r\n\r\n  componentWillMount() {\r\n    api().getList(this.props.name).then(\r\n      items => this.setState({ items })\r\n    );\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps) {\r\n    return !shallowEqual(props, nextProps);\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"shopping-list\">\r\n        <h1>Shopping List for {this.props.name}</h1>\r\n        <ul>\r\n          {this.state.items.map(item => (\r\n            <li>{item}</li>\r\n          ))}\r\n        </ul>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n### Refactoring\r\n\r\nThe obvious place to start is to take out the `render` method and make it a new function:\r\n\r\n```jsx\r\nconst renderShoppingList = (props) => {\r\n  return (\r\n    <div className=\"shopping-list\">\r\n      <h1>Shopping List for {props.name}</h1>\r\n      <ul>\r\n        {props.items && props.items.map(item => (\r\n          <li>{item}</li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\nFunctions don't have state, so the shopping cart contents have to come from `props`. We'll talk about it in a moment.\r\n\r\nLet's take a look at lifecycle methods now. This concept is a React specialty, really, so we need to heave a React-specific implementation. This new function is going to take some parameters - a lifecycle specification - and pass them on to React:\r\n\r\n```jsx\r\nconst lifecycle = (spec) => (Enhanced) =>\r\n    React.createClass({\r\n        ...spec,\r\n        render() {\r\n            return <Enhanced {...this.props} />\r\n        }\r\n    })\r\n```\r\n\r\nYou see that in the `render` method we just render `Enahnced`. That's the React component that is being wrapped in `lifecycle` HoC.\r\n\r\n\r\n```jsx\r\nconst renderShoppingList = (props) => {\r\n  const { name, items } = props;\r\n\r\n  return (\r\n    <div className=\"shopping-list\">\r\n      <h1>Shopping List for {this.props.name}</h1>\r\n      <ul>\r\n        {this.state.items.map(item => (\r\n          <li>{item}</li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst lifecycleSpec = {\r\n  componentDidMount() {\r\n    api().getList(this.props.name).then(\r\n      items => this.props.setItems(items)\r\n    );\r\n  }\r\n}\r\n\r\nconst ShoppingList = lifecycle(lifecycleSpec)(renderShoppingList)\r\n```\r\n\r\nI think you understand the idea by now. We are still missing the code that will replace the component state behaviour. \r\n\r\n```jsx\r\nconst withState = (\r\n  stateName,\r\n  stateUpdaterName,\r\n  initialState\r\n) => Enhanced => {\r\n  class WithState extends Component {\r\n    state = {\r\n      stateValue: initialState,\r\n    }\r\n\r\n    updateStateValue = (value) =>\r\n      this.setState(\r\n        ({ stateValue }) => ({\r\n          stateValue: value\r\n        })\r\n      )\r\n\r\n    render() {\r\n      return (\r\n        <Enhanced {{\r\n          ...this.props,\r\n          [stateName]: this.state.stateValue,\r\n          [stateUpdaterName]: this.updateStateValue,\r\n        }}\r\n      />\r\n    }\r\n  }\r\n\r\n  return WithState\r\n}\r\n```\r\n\r\nThis new HOC will render the `Enhanced` component, and add two new props to it. The props will manage state on the parent React component . Let's use it:\r\n\r\n```jsx\r\nconst renderShoppingList = (props) => {\r\n  const { name, items } = props;\r\n\r\n  return (\r\n    <div className=\"shopping-list\">\r\n      <h1>Shopping List for {this.props.name}</h1>\r\n      <ul>\r\n        {this.state.items.map(item => (\r\n          <li>{item}</li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst lifecycleSpec = {\r\n  componentDidMount() {\r\n    api().getList(this.props.name).then(\r\n      items => this.props.setItems(items)\r\n    );\r\n  }\r\n}\r\n\r\nconst ShoppingList = withState('items', 'setItems', [])(lifecycle(lifecycleSpec)(renderShoppingList))\r\n```\r\n\r\nDamn, the last line is ugly. Luckily, we're just calling functions here. This means we can use `compose` function from the previous JS example.\r\n\r\n### Refactoring result\r\n\r\nWe've successfully split a tightly-coupled React class component into a render function and a set of reusable higher-order components.\r\n\r\n`react-fp.js` contains the HOCs:\r\n\r\n```jsx\r\nexport const lifecycle = (spec) => (Enhanced) =>\r\n    React.createClass({\r\n        ...spec,\r\n        render() {\r\n            return <Enhanced {...this.props} />\r\n        }\r\n    })\r\nexport const withState = (\r\n    stateName,\r\n    stateUpdaterName,\r\n    initialState\r\n  ) => Enhanced => {\r\n    class WithState extends Component {\r\n      state = {\r\n        stateValue: initialState,\r\n      }\r\n\r\n      updateStateValue = (value) =>\r\n        this.setState(\r\n          ({ stateValue }) => ({\r\n            stateValue: value\r\n          })\r\n        )\r\n\r\n      render() {\r\n        return (\r\n          <Enhanced {{\r\n            ...this.props,\r\n            [stateName]: this.state.stateValue,\r\n            [stateUpdaterName]: this.updateStateValue,\r\n          }} />\r\n        )\r\n      }\r\n    }\r\n\r\n    return WithState\r\n  }\r\n\r\nexport const compose = (...functors) => \r\n    functors.reduce(\r\n        (s, c) => (...args) => s(c(...args))\r\n    )\r\n```\r\n\r\n`ShoppingList.jsx` makes use of those HOCs to abstract away all React specifics:\r\n\r\n```jsx\r\nconst renderShoppingList = (props) => {\r\n  const { name, items } = props;\r\n\r\n  return (\r\n    <div className=\"shopping-list\">\r\n      <h1>Shopping List for {this.props.name}</h1>\r\n      <ul>\r\n        {this.state.items.map(item => (\r\n          <li>{item}</li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst lifecycleSpec = {\r\n  componentDidMount() {\r\n    api().getList().then(\r\n      items => this.setState({ items })\r\n    );\r\n  }\r\n}\r\n\r\nconst ShoppingList = compose(\r\n  withState('items', 'setItems', []),\r\n  lifecycle(lifecycleSpec),\r\n)(renderShoppingList);\r\n\r\nexport default ShoppingList\r\n```\r\n\r\n### Experiment\r\n\r\nSo now that we have the React-specific code moved to a separate module, let's have some fun. I'm going to change the view library from React to Inferno, modify the `react-fp.js` to become `inferno-fp.js`. I don't have to modify my `ShoppingList.js` code at all, since I don't use React in it directly.\r\n\r\nThis is how `inferno-fp.js` looks like:\r\n\r\n```jsx\r\nimport { Component } from 'inferno';\r\n\r\n/**\r\n * Lazy implementation of lifecycle HoC \r\n * TODO: Add more lifecycle methods\r\n */\r\nconst lifecycle = spec => Enhanced => (props = {}) => (\r\n  <Enhanced\r\n    {...props}\r\n    onComponentDidMount={() => spec.componentDidMount(props)}\r\n  />\r\n);\r\n\r\nconst compose = (...functors) =>\r\n  functors.reduce(\r\n    (s, c) => (...args) => s(c(...args))\r\n  );\r\n\r\nconst withState = (\r\n  stateName,\r\n  stateUpdaterName,\r\n  initialState\r\n) => Enhanced => {\r\n  class WithState extends Component {\r\n    state = {\r\n      stateValue: initialState,\r\n    }\r\n\r\n    updateStateValue = (value) =>\r\n      this.setState(\r\n        ({ stateValue }) => ({\r\n          stateValue: value\r\n        })\r\n      )\r\n\r\n    render() {\r\n      const extraProps = {\r\n        [stateName]: this.state.stateValue,\r\n        [stateUpdaterName]: this.updateStateValue,\r\n      }\r\n\r\n      return (\r\n        <Enhanced {...this.props} {...extraProps} />\r\n      )\r\n    }\r\n  }\r\n\r\n  return WithState\r\n}\r\n\r\nexport {\r\n  compose,\r\n  lifecycle,\r\n  withState,\r\n};\r\n```\r\n\r\nI'm really lazy and I didn't implement all the lifecycle methods - but you will forgive me this, won't you? Apart from this, the HOC interface is exactly the same. There is no need to do anything in `ShoppingList.js`, just replace the imported module. You can try the complete example on [GitHub](https://github.com/iakovmarkov/react-inferno-example) yourself.\r\n\r\nAs I've said in the beginning, the practical application of this is very limited. However, it's a great demonstration of why I prefer functional approach to programming complex applications now. Composing loosely coupled functions together enables you to replace them with relative ease. Refactoring such code is much easier as well, because modules are not dependant on one another and can be swapped out, given their APIs are compatible.\r\n\r\n## Conclussion\r\n\r\nWhen we have applied this for the first time in Ataccama, our junior developers and newcomers were really confused with the concept. However, after a few weeks of working with the project that uses higher-order components a lot, they've learned how to quickly compose HOCs to get the desired behavior. Separating the business logic from the render code allowed us to have a standard UI library that is shared across different web applications.\r\n\r\nI hope reading this has been beneficial to you. Even if you won't rewrite your code into functional components immediately, you can apply certain ideas to other areas of programming. If you are interested in learning more about functional programming in React, check out [Reusable Higher-Order Components](/blog/reusable_hocs).\r\n\r\n## Useful links\r\n\r\n- [Recompose](https://github.com/acdlite/recompose) - a library that gives you a ton of reusable HoCs, making the transition easier.\r\n- [Recompost](https://github.com/adam-stanek/recompost) - our colleague's version of Recompose, but with TypeScript capabilities. Just awesome.\r\n"},"__N_SSG":true}