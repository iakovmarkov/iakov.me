{"pageProps":{"raw":"---\r\ntitle: Reusable Higher-Order Components\r\ndate: 2018-12-02\r\ntags:\r\n- Programming\r\n- Functional programming\r\n- React\r\n- Recompose\r\n- JavaScript\r\n---\r\nIn this blog post I will talk about how to create reusable higher-order components in React on a practical example - working with an API.\r\n---\r\n\r\n## Intro\r\n\r\nThis is a third post about functional programming in React. In the previous posts I've demonstrated how FP applies to JavaScript and React, and explained the concept of higher-order components.\r\n\r\nI believe that the main benefit of FP approach is reusability. If your business logic is separated from your render code, the later can be reused in different context or even application, given the interface for the render function is flexible enough. But the business logic itself can also be implemented as a higher-order function. You can take any piece of code that is present in multiple places in your project, give it a name and interface, and use functional composition to attach it to your components.\r\n\r\nIf you are not familiar with the concept of higher-order components, I recommend taking a look at [Higher-Order Components in React](/blog/react_hocs) first.\r\n\r\n## Practical example\r\n\r\nLet's take a simple practical example. You are developing a single-page application that needs to talk to an API to get any data in or out. Your application has a sign-in form, and a sign-up form, that both send POST requests to server. They also display request state and have to react to errors.\r\n\r\nIt's tempting to duplicate the calls to your API in both of those components. They use different API endpoints, they handle errors differently, the data that they send and receive is also different. But if you consider an SPA that has a hundred of API calls, repeated across tens of modules, you will get a different picture. The amount of boilerplate code to set request state, handle errors or pass the response will become the vast majority of the code you duplicate. This makes it error-prone, hard to test and messy.\r\n\r\nWe will refactor those forms to use a new higher-order component that handles talking to an API. This HOC will itself be composed of smaller HOCs, to demonstrate the idea once more.\r\n\r\n### Form classes\r\n\r\nThose are our two forms, implemented as classic React class components.\r\n\r\n```jsx\r\nclass LoginForm extends React.Component {\r\n    state = {\r\n        submitting: false,\r\n        error: null,\r\n        success: null,\r\n    }\r\n\r\n    handleSubmit() {\r\n        this.setState({ submitting: true })\r\n        const data = {\r\n            email: document.querySelector('#email').value,\r\n            password: document.querySelector('#password').value,\r\n        }\r\n        api().post('/login', JSON.stringify(data)).then(\r\n            (res) => {\r\n                const error = res.error || this.state.error\r\n                const success = res.code === 200 || this.state.success\r\n\r\n                this.setState({ submitting: false, error, success })\r\n            }\r\n        )\r\n    }\r\n\r\n    render() {\r\n        if (this.state.submitting) {\r\n            return <span>Submitting...</span>\r\n        }\r\n        if (this.state.error) {\r\n            return <span>An error has occured! Try again. More info: {this.state.error}</span>\r\n        }\r\n        if (this.state.success) {\r\n            return <span>Logged in successfully, redirecting...</span>\r\n        }\r\n        return (\r\n            <form onSubmit={this.handleSubmit}>\r\n                <input name=\"email\" id=\"email\" placeholder=\"Email\" />\r\n                <input name=\"password\" id=\"password\" type=\"password\" />\r\n                <button type=\"submit\" value=\"Log in\"/>\r\n            </form>\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n```jsx\r\nclass RegisterForm extends React.Component {\r\n    state = {\r\n        submitting: false,\r\n        error: null,\r\n        success: null,\r\n    }\r\n\r\n    handleSubmit() {\r\n        const email = document.querySelector('#email').value\r\n        const username = document.querySelector('#username').value\r\n        const password = document.querySelector('#password').value\r\n        const password_confirm = document.querySelector('#password_confirm').value\r\n        \r\n        if (password !== password_confirm) {\r\n            alert(\"Passowrds don't match!\")\r\n            return\r\n        }\r\n\r\n        this.setState({ submitting: true })\r\n        const data = {\r\n            username,\r\n            email,\r\n            password,\r\n            password_confirm,\r\n        }\r\n        api().post('/signup', JSON.stringify(data)).then(\r\n            (res) => {\r\n                const error = res.error || this.state.error\r\n                const success = res.code === 200 || this.state.success\r\n\r\n                this.setState({ submitting: false, error, success })\r\n            }\r\n        )\r\n    }\r\n\r\n    render() {\r\n        if (this.state.submitting) {\r\n            return <span>Submitting...</span>\r\n        }\r\n        if (this.state.error) {\r\n            return <span>An error has occured! Try again. More info: {this.state.error}</span>\r\n        }\r\n        if (this.state.success) {\r\n            return <span>Account created successfully, redirecting...</span>\r\n        }\r\n        return (\r\n            <form onSubmit={this.handleSubmit}>\r\n                <input name=\"username\" id=\"username\" placeholder=\"Username\" />\r\n                <input name=\"email\" id=\"email\" placeholder=\"Email\" />\r\n                <input name=\"password\" id=\"password\" type=\"password\" />\r\n                <input name=\"password_confirm\" id=\"password_confirm\" type=\"password\" />\r\n                <button type=\"submit\" value=\"Sign up\"/>\r\n            </form>\r\n        )\r\n    }\r\n}\r\n```\r\n\r\nEven with two forms, you can see how much of the code is duplicated. Most of it is boilerplate that you will duplicate every time you need to get something from the API.\r\n\r\n### Creating a complex HOC\r\n\r\nLet's refactor those components using functional programming techniques. We will create a higher-order component that injects request state, server response and a handler function into the component it will enhance.\r\n\r\nTo save time, we won't implement `compose`, `withState` or any other higher-order function. Instead, let's use [Recompose](https://github.com/acdlite/recompose) - a very well-made and well-documented library full of basic HOCs like that.\r\n\r\nLet's move all API-related code into a higher-order component:\r\n\r\n```javascript\r\nconst withApi = (endpoint, method) => compose(\r\n    withState('apiState', 'setApiState', { pending: false, error: null, response: null }),\r\n    withHandlers((props) => ({\r\n        apiRequest: (data) => {\r\n            const call = api()[method]\r\n\r\n            props.setApiState({ pending: true })\r\n\r\n            call(endpoint, data).then((res) => {\r\n                const error = res.error || props.error\r\n                const response = res.code === 200 ? res.body : props.response\r\n\r\n                props.setApiState.setState({ pending: false, error, response })\r\n            })\r\n        }\r\n    })),\r\n    omitProps(['setApiState']),\r\n)\r\n```\r\n\r\nAs you see, we've moved all the API-related code into this reusable higher-order component. It uses other simple HOCs to create pretty complex behaviour.\r\n\r\n### Using the HOC\r\n\r\nNow, let's refactor our form components to use the `withApi` HOC. The goal is to remove all API implementation details, and use props that are passed down instead.\r\n\r\nThe results look like this:\r\n\r\n```jsx\r\nconst LoginForm = withApi('/login', 'post')(\r\n    (props) => {\r\n        if (props.apiState.pending) {\r\n            return <span>Submitting...</span>\r\n        }\r\n        if (props.apiState.error) {\r\n            return <span>An error has occured! Try again. More info: {props.apiState.error}</span>\r\n        }\r\n        if (props.apiState.response) {\r\n            return <span>Logged in successfully, redirecting...</span>\r\n        }\r\n        return (\r\n            <form\r\n                onSubmit={() => props.apiRequest({\r\n                    email: document.querySelector('#email').value,\r\n                    password: document.querySelector('#password').value,\r\n                })}\r\n            >\r\n                <input name=\"email\" id=\"email\" placeholder=\"Email\" />\r\n                <input name=\"password\" id=\"password\" type=\"password\" />\r\n                <button type=\"submit\" value=\"Log in\"/>\r\n            </form>\r\n        )\r\n    }\r\n)\r\n\r\nconst RegisterForm = compose(\r\n    withApi('/register', 'post'),\r\n    withHandlers(props => ({\r\n        handleSubmit: (data) => {\r\n            if (data.password !== data.password_confirm) {\r\n                alert(\"Passowrds don't match!\")\r\n                return\r\n            }\r\n\r\n            props.apiRequest(data)\r\n        }\r\n    }))\r\n)(\r\n    (props) => {\r\n        if (props.apiState.pending) {\r\n            return <span>Submitting...</span>\r\n        }\r\n        if (props.apiState.error) {\r\n            return <span>An error has occured! Try again. More info: {props.apiState.error}</span>\r\n        }\r\n        if (props.apiState.response) {\r\n            return <span>Account created successfully, redirecting...</span>\r\n        }\r\n        return (\r\n            <form \r\n                onSubmit={() => props.handleSubmit({\r\n                    username: document.querySelector('#username').value,\r\n                    email: document.querySelector('#email').value,\r\n                    password: document.querySelector('#password').value,\r\n                    password_confirm: document.querySelector('#password_confirm').value,\r\n                })}\r\n            >\r\n                <input name=\"username\" id=\"username\" placeholder=\"Username\" />\r\n                <input name=\"email\" id=\"email\" placeholder=\"Email\" />\r\n                <input name=\"password\" id=\"password\" type=\"password\" />\r\n                <input name=\"password_confirm\" id=\"password_confirm\" type=\"password\" />\r\n                <button type=\"submit\" value=\"Sign up\"/>\r\n            </form>\r\n        )\r\n    }\r\n)\r\n```\r\n\r\nAs you can see, the usage of `withApi` is really simple - it only needs two parameters, and it passes down two new props - `apiState` and `apiRequest`. It's interface can be extended via optional arguments later. \r\n\r\nif we want to do something to the data before sending it to the server, like validate or transform it, we can use a higher-order component again. I've done it in `RegisterForm` to demonstrate how to implement non-standard cases while still reaping the beneifts of functional composition.\r\n\r\nThe code above can be further improved by moving code related to API request state into a separate component, but it's out of scope of this post.\r\n\r\n## Conclussion\r\n\r\nThis post is meant to be the last in the series about functional programming in React. I wrote it to explain the concepts to a relatively inexperienced developer, or someone who is coming from an object-oriented language like Java. I believe that I gave a good overview - from showing how functional programming is native to JavaScript to creating a reusable higher-order component.\r\n\r\nI don't think that FP is necessarily superior to object-oriented approach, but it makes a lot of sense to me in context of React. React [documentation](https://reactjs.org/docs/composition-vs-inheritance.html) mentions FP a lot, and core team members have [expressed preference for it](https://twitter.com/dan_abramov/status/752643494972383232). \r\n\r\nMy experience tells me that functional programming works well in a very big codebase that is shared across different product teams. Working with the functional code was good developer experience, it fascilitated a lot of code reuse and encouraged engineers to have good test coverage of reused code. FP became my favorite paradigm, and I have learned to apply it in other languages like Python and Go.\r\n\r\n## Useful links\r\n\r\n- [SOLID: The next step is functional](https://blog.ploeh.dk/2014/03/10/solid-the-next-step-is-functional/) - an article about the virtues of functional programming."},"__N_SSG":true}